{% macro directive_hook(view, hookName) %}
{% for directive in view.directives %}{{ directive.getHookCode(hookName, view) }}{% endfor %}
{% endmacro %}

{% macro make_view_function(view, interpolator, styleProcessor, typeInferer) %}
{% import _self as self %}

{# TODO: no longer using isDynamic() or hasDynamicChild(), should remove if not needed #}
    private {% if view.parent != null %}ViewFactory{% else %}View{% endif %} makeView_{{ view.id }}(final BaseScreen _screen{% if view.parent != null %}, final DynamicViewGroup _parentView, final {{ view.parent.scopeDefinition.getScopeClassName() }} _parentNodeScope{% endif %}) {
        {% if view.parent != null %}final {{ view.parent.scopeDefinition.getScopeClassName() }} scope = _parentNodeScope;
        {% if view.parent.scopeDefinition.getParentScope() != null %}final {{ view.parent.scopeDefinition.getParentScope().getScopeClassName() }} _parent = scope._parent;{% endif %}
        {% for property in view.parent.scopeDefinition.allProperties() %}final {{ property.type }} {{ property.name }} = {{ property.accessCode() }};
        {% endfor %}{% endif %}

    {% if view.parent != null %}
        final ViewFactory result = new ViewFactory() {
            public void createViews(final ViewGroup parent) {
    {% endif %}

        {{ self.directive_hook(view, "beforeScopeCreated") }}

        View result = new ScopedViewFactory() {
            @Override
            public View make() {

                final {{ view.getViewClassName() }} result = _viewRecycler.makeView({{ view.getViewClassName() }}.class, _screen);

                {% if view.hasScope() %}final {{ view.scopeDefinition.getScopeClassName() }} scope = {% if not view.scopeDefinition.isPassthroughScope() %}new {{ view.scopeDefinition.getScopeClassName() }}(_handler, result{% if view.parent != null %}, _parentNodeScope{% endif %}){% else %}({{ view.scopeDefinition.getScopeClassName() }})_parentNodeScope{% endif %};
                {% if view.scopeDefinition.getParentScope() != null %}final {{ view.scopeDefinition.getParentScope().getScopeClassName() }} _parent = scope._parent;{% endif %}
                {% for property in view.scopeDefinition.ownProperties() %}final {{ property.type }} {{ property.name }} = scope.{{ property.name }};
                {% endfor %}{% endif %}

                {{ self.directive_hook(view, "beforeViewCreated") }}

                result.setVisibility(View.VISIBLE);
                {% if typeInferer.isAssignable(view.getViewClassName(), "com.flarestar.drones.views.viewgroups.ScopedViewGroup") %}
                ((ScopedViewGroup)result).setScope(scope);
                {% endif %}

                {% if view.text != null and not view.text.isEmpty() %}result.setText({{ interpolator.interpolate(view.text) }});{% endif %}
                {{ styleProcessor.process(view) }}

                {{ self.directive_hook(view, "afterViewCreated") }}

                {% for event in view.scopeDefinition.events %}
                scope.on({{ event.eventClass.getName() }}.class, new Listener<{{ event.eventClass.getName() }}>() {
                    @Override
                    public boolean invoke({{ event.eventClass.getName() }} event) {
                        try {
                            {{ event.expression }};
                            scope.apply();
                            return true;{# TODO: how to handle propagation in directive attributes? #}
                        } catch (Exception e) {
                            throw new RuntimeException("Unexpected error when invoking event handler.", e);
                        }
                    }
                });
                {% endfor %}

                {% for child in view.children %}
                result.addChildDefinition(makeView_{{ child.id }}(_screen, result, scope));
                {% endfor %}
                {% if view.children.size() != 0 %}result.createChildren();{% endif %}{# TODO: shouldn't recreate on first watch in this case, will be redundant, eg, w/ ng-repeat #}

                {{ self.directive_hook(view, "afterChildrenAdded") }}

                return result;
            }
        }.make();

    {% if view.parent != null %}parent.addView(result);

                {{ self.directive_hook(view, "afterViewAdded") }}
            }
        };
    {% endif %}

        {{ self.directive_hook(view, "beforeReturnResult") }}

        return result;
    }

    {% for child in view.children %}
    {{ self.make_view_function(child, interpolator, styleProcessor, typeInferer) }}
    {% endfor %}
{% endmacro %}